<html>
	<head>
		<title>Pizza man!</title>

		<style type="text/css">
			body {background-color: indianred;
				background-image: url("pizza.jpg");
				background-repeat: no-repeat;
				background-position: 75% 50%;
				height: 900px}

			.game {
				margin-left: auto;
				margin-right: auto;
				border: 1px solid black;
				display: inline;
			}
			.gamediv {
				width: 100%;
				text-align: center;
			}
		</style>
	</head>

	<body>
		<audio src="malt.mp3" controls></audio>
		<p>&nbsp</p>
		<div class="gamediv">
			<canvas id="pizzagame" class="game" width="800" height="600">Pizza did not load</canvas>
		</div>
	</body>

	<script>
		const canvas = document.getElementById("pizzagame");
		const render = canvas.getContext("2d");


		// Game variables
		let score = 0;
		let wordsperorder = 1;					// How many words in an order.
		let successcount = 0;					// How many successful orders have been made by the player.
		const LEVELUPTHRESHOLD = 5;				// How many successful orders must be made before the game adds more words to order.

		let framestarttime = Date.now();
		let lastframetime = Date.now();
		let orderendtime = Date.now();
		let deltatime = 0;
		let lives = 3;

		let state = 0;


		let completeingredientarray = 
			[];

		let incompleteingredientarray = 
			[{"word": "pizza", "currentletter": 0}
			];

		// List of words.			Add word graphics much later.
		const wordlist = [
			{"word": "pepperoni", "graphic": ""},
			{"word": "mozzarella", "graphic": ""},
			{"word": "bell pepper", "graphic": ""},
			{"word": "tomato", "graphic": ""},
			{"word": "olive", "graphic": ""}
		];

		const WORDLISTLENGTH = wordlist.length;

		// Order text
		let orderlinegreen = 
			["",
			"", 
			"", 
			"", 
			"", 
			"", 
			"" ];
		let orderlinered = 
			["", 
			"", 
			"", 
			"", 
			"", 
			"", 
			"" ];
		let orderlineblack = 
			["", 
			"", 
			"",
			"",
			"",
			"",
			""];


		// Enumerations for the state machine.
		const LOADING = 0;
		const BEFOREGAME = 1;
		const CREATEPIZZA = 2;
		const TYPING = 3;
		const BEGINSUCCESS = 4
		const SUCCESS = 5;
		const BEGINFAIL = 6;
		const FAIL = 7;
		const BEFORECREATEPIZZA = 8;
		const GAMEOVER = 9;
		const BEFORETYPING = 10;

		// Graphics

		const defaultpizzax = 400;
		const defaultpizzay = 200;

		let pizzax = 0;
		let pizzay = 0;

		window.requestAnimationFrame(drawgame);
		let srcarray = [
			"check.png", "x.png"
			]
		let imagestoload = srcarray.length;		// This integer will be used to check if every graphic has been loaded before launching the game.

		let graphicdict = new Map();

		function populategraphicmap(){
			srcarray.forEach((element) =>{
				let newimage = new Image();

				newimage.onload = function () {
					imagestoload -= 1;
					if(imagestoload <= 0){
						state = TYPING;  	// Change later to BEFOREGAMEf
						filltextlists();
					}
				}

				newimage.src = "pizzagraphic/" + element;

				graphicdict.set(element, newimage);
			})
		}


		function drawgame(){
			// Timing
			lastframetime = framestarttime;
			framestarttime = Date.now();
			deltatime = (framestarttime - lastframetime) / 1000;

			switch(state){
			case LOADING: 
				drawloadscreen();
				break;
			case BEFORETYPING:
				filltextlists();
				state = TYPING;

				render.clearRect(0, 0, 800, 600);
				drawbackground();
				drawcrust(defaultpizzax, defaultpizzay);
				draworder();
				drawtimer();
				drawlives();
				break;
			case TYPING:
				render.clearRect(0, 0, 800, 600);
				drawbackground();
				drawcrust(defaultpizzax, defaultpizzay);
				draworder();
				drawtimer();
				drawlives();
				break;
			case SUCCESS:
				pizzax += 800 * deltatime;

				if(pizzax > 800) {
					state = BEFORECREATEPIZZA;
				}

				render.clearRect(0, 0, 800, 600);
				drawbackground();
				drawcrust(defaultpizzax + pizzax, defaultpizzay);
				drawtimer();
				drawlives();
				break;
			case BEFORECREATEPIZZA:
				pizzax = -800;
				// Restart timer.

				state = CREATEPIZZA;

				render.clearRect(0, 0, 800, 600);
				drawbackground();
				drawlives();
				generateorder();
				break;
			case CREATEPIZZA:
				pizzax += 800 * deltatime;

				if(pizzax >= 0) {
					pizzax = 0;
					state = BEFORETYPING;
				}

				render.clearRect(0, 0 , 800, 600);
				drawbackground();
				drawlives();
				drawcrust(defaultpizzax + pizzax, defaultpizzay);
				break;
			case FAIL:
				pizzay -= 1600 * deltatime;

				if (pizzay < -1000) {
					state = BEFORECREATEPIZZA
					pizzay = 0;
				}

				render.clearRect(0, 0, 800, 600);
				drawbackground();
				drawlives();
				drawcrust(defaultpizzax, defaultpizzay + pizzay)
				draworder();
				drawtimer();
			}
			requestAnimationFrame(drawgame);
		}


		function drawloadscreen(){
			render.beginPath();
			render.rect(0, 0, 800, 600);
			render.fillStyle = "black";
			render.fill();
			render.closePath();

			render.font = "60px serif";
			render.fillStyle = "white";
			render.fillText("Loading...", 100, 100);
		}


		function drawbackground(){
			// Counter
			render.beginPath();
			render.rect(0, 0, 800, 400);
			render.fillStyle = "silver";
			render.fill();
			render.closePath();

			// Paper
			render.beginPath();
			render.rect(0, 400, 800, 200);
			render.fillStyle = "beige";
			render.fill();
			render.closePath();
		}


		function drawcrust(x, y){
			render.beginPath();
			render.arc(x, y, 175, 0, 2 * Math.PI);
			render.fillStyle = "#DBBB6D";
			render.fill();
			render.closePath();
		}


		function draworder(){
			const BEGINLINE = 10;
			let textstart = BEGINLINE;

			for (let i = 0; i < 7; i++){
			render.font = "24px serif";
			render.fillStyle = "green";
			render.fillText(orderlinegreen[i], 10, 430 + (24 * i));
			measure = render.measureText(orderlinegreen[i]);
			textstart +=  measure.width;
			render.fillStyle = "red";
			render.fillText(orderlinered[i], textstart, 430+ (24 * i));
			measure = render.measureText(orderlinered[i]);
			textstart += measure.width;
			render.fillStyle = "black";
			render.fillText(orderlineblack[i], textstart, 430+ (24 * i));
			textstart = BEGINLINE;
			}

		}


		function drawtimer(){
			render.font = "24px serif";
			render.fillStyle = "black";
			render.fillText("Time :00", 675, 30);
		}


		function drawlives(){
			let lifecounter = lives;		// This counts the amount of lives the player has in the for loop so the program knows whether to draw an x or check.
			let currentgraphic = graphicdict.get("check.png")
			for(let i = 0; i <= 2; i++){
				if (lifecounter <= 0){
					currentgraphic = graphicdict.get("x.png");				}
				render.drawImage(currentgraphic, 675 + (i * 32), 40);
				lifecounter -= 1;
			}
		}

		function cleartextgraphics(){
			orderlinegreen = ["", "", "", "", "", "", ""];
			orderlinered = ["", "", "", "", "", "", ""];
			orderlineblack = ["", "", "", "", "", "", ""];
		}

		function filltextlists(){
			let currentline = 0;
			let wordnumber = 0;

			// Erase all graphic text lists.
			cleartextgraphics();

			function addwordnumber(){
				wordnumber += 1;

				if(wordnumber > 9){
					wordnumber = 0;
					currentline += 1;
				}
			}

			for(i = 0; i < completeingredientarray.length; i++){			// Counting all completed words.
				orderlinegreen[currentline] += completeingredientarray[i];
				addwordnumber();
			}
			if(incompleteingredientarray.length > 0){				
				for(i = 0; i < incompleteingredientarray[0].word.length; i++){	// Building the first word
					if(i < incompleteingredientarray[0].currentletter){									// Already typed letters.
						orderlinegreen[currentline] += (incompleteingredientarray[0].word.charAt(i));
					}
					else if(i == incompleteingredientarray[0].currentletter){							// Current letter to type.
						orderlinered[currentline] += (incompleteingredientarray[0].word.charAt(i));
					}
					else{																				// Letters that haven't been typed yet.
						orderlineblack[currentline] += (incompleteingredientarray[0].word.charAt(i));
					}
				}
			}

			addwordnumber();

			for(i = 1; i < incompleteingredientarray.length; i++){									// Counting all words that haven't been typed.
				orderlineblack[currentline] += (incompleteingredientarray[i].word);
				addwordnumber();
			}
		}


		// Input.

		document.addEventListener("keydown", (event) => {
			switch(state) {
			case TYPING: 
				if(event.key === incompleteingredientarray[0].word.charAt(incompleteingredientarray[0].currentletter)) {	// Player has typed highlighted letter.
					incompleteingredientarray[0].currentletter += 1;

					if(incompleteingredientarray[0].currentletter == incompleteingredientarray[0].word.length)				// Player has completed a word.
					{
						completeingredientarray.push(incompleteingredientarray[0].word);
						incompleteingredientarray.splice(0, 1);
					}

					if(incompleteingredientarray.length == 0){																// Player has completed order.
						state = SUCCESS;
						successlogic();
					}
					filltextlists();
				} else if (event.key === "Shift") {	// Allows capitalization of letters without losing score.
						// Do nothing.
				} else if (event.key === "Control" || event.key === "Alt" || event.key === "Tab") { 						// Exclude other inputs like tab, control, and alt so player does not lose score.
					// Do nothing.
				} else {							// Player fails at typing highlighted letter.
					faillogic();
				}
				break;
			}

			if(event.keyCode == 32 && event.target == document.body) {		// Prevents page from scrolling down when player presses spacebar. 
				event.preventDefault();
			}
		})

		// Game logic

		function generateorder() {
			let remainingwords = wordsperorder;
			incompleteingredientarray = [];

			// Pick random word from list, reduce remainingwords by 1, and capitalizes first word.
			let randomnumber = Math.floor(Math.random() * WORDLISTLENGTH);
			let newword = wordlist[randomnumber]["word"];
			const firstletter = newword.charAt(0).toUpperCase();
			const restofword = newword.slice(1);

			incompleteingredientarray.push({"word": firstletter + restofword, "currentletter": 0}); //{"word": "pizza", "currentletter": 0}
			remainingwords--;

			while(remainingwords > 0) {
				// Add comma first.
				incompleteingredientarray.push({"word": ", ", "currentletter": 0});

				// Add word.
				randomnumber = Math.floor(Math.random() * WORDLISTLENGTH);
				incompleteingredientarray.push({"word": wordlist[randomnumber].word, "currentletter": 0});
				remainingwords--;
			}
		}

		function successlogic() {
			score += 100;
			successcount++;
			completeingredientarray = [];

			if (successcount >= LEVELUPTHRESHOLD) {
				wordsperorder++;
				successcount = 0;
			}
		}

		function faillogic() {
			state = FAIL;
			completeingredientarray = [];
			lives--;
		}


		// Game start
		populategraphicmap();
		filltextlists();

	</script>
</html>